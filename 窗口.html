<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®€å†ç”Ÿæˆ</title>
    <style>
        /* å…¨å±€æ ·å¼ */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #F7F8FA;
            min-height: 100vh;
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        /* å®¹å™¨æ ·å¼ */
        .container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
            padding: 30px;
            width: 100%;
            max-width: 650px;
        }
        
        /* æ ‡é¢˜æ ·å¼ */
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
            font-size: 28px;
            font-weight: 600;
        }
        
        /* è¡¨å•æ ·å¼ */
        .form-group {
            margin-bottom: 25px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #555;
            font-weight: 500;
            font-size: 14px;
        }
        
        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
            background-color: #f9fafb;
        }
        
        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #3B82F6;
            background-color: white;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        /* æŒ‰é’®æ ·å¼ */
        #submitBtn {
            width: 100%;
            padding: 14px;
            background-color: #3B82F6;
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 25px;
        }
        
        #submitBtn:hover {
            background-color: #2563EB;
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.3);
        }
        
        #submitBtn:active {
            transform: translateY(0);
        }
        
        /* ç»“æœåŒºåŸŸæ ·å¼ */
        #result {
            background: #f8fafc;
            border-radius: 12px;
            padding: 24px;
            border: 1px solid #e2e8f0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }
        
        #result h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: 600;
        }
        
        #httpResult {
            color: #475569;
            font-size: 16px;
            line-height: 1.6;
            word-break: break-all;
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        
        /* åŠ è½½çŠ¶æ€åŠ¨ç”» */
        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }
        
        #httpResult.loading {
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 24px;
            }
            
            .form-group input,
            .form-group select,
            #submitBtn {
                font-size: 14px;
                padding: 10px 12px;
            }
        }
        
        /* é“¾æ¥æ ·å¼ */
        #httpResult a {
            color: #3B82F6;
            text-decoration: none;
            font-weight: 500;
            border-bottom: 1px solid transparent;
            transition: all 0.3s ease;
        }
        
        #httpResult a:hover {
            color: #2563EB;
            border-bottom-color: #2563EB;
        }
    </style>
</head>
<body>
    <div class="container">
    <h1>ç®€å†ç”Ÿæˆ</h1>
    
    <div class="form-group">
        <label for="inputText">äººç‰©ä¿¡æ¯:</label>
        <textarea id="inputText" name="inputText" rows="15" cols="60" placeholder="è¯·è¾“å…¥éœ€è¦å¤„ç†çš„æ–‡æœ¬å†…å®¹..."></textarea>
    </div>
    
    <div class="form-group">
        <label for="selectT">é€‰æ‹©æ¨¡æ¿:</label>
        <select id="selectT" name="selectT">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
        </select>
    </div>
    
    <button id="submitBtn">æäº¤</button>
    
    <div id="result">
        <h3>è¿”å›ç»“æœ:</h3>
        <p id="httpResult"></p>
    </div>
    </div>

    <script>
        document.getElementById('submitBtn').addEventListener('click', function() {
            const input = document.getElementById('inputText').value;
            const t = document.getElementById('selectT').value;

            const requestData = {
                "inputs": {
                    "input": input,
                    "t": t
                },
                "response_mode": "streaming",
                "user": "1"
            };

            console.log('å‡†å¤‡å‘é€è¯·æ±‚...');
            console.log('è¯·æ±‚URL:', 'http://121.43.104.146:8088/v1/workflows/run');
            console.log('è¯·æ±‚æ•°æ®:', requestData);
            
            // æ£€æµ‹å½“å‰ç¯å¢ƒ
            const isLocalFile = window.location.protocol === 'file:';
            const isHttps = window.location.protocol === 'https:';
            const isGitHubPages = window.location.hostname.includes('github.io');
            
            // APIæœåŠ¡å™¨åªæ”¯æŒHTTPï¼Œä¸æ”¯æŒHTTPS
            // GitHub Pageså¼ºåˆ¶ä½¿ç”¨HTTPSï¼Œå¯¼è‡´æµè§ˆå™¨é˜»æ­¢æ··åˆå†…å®¹
            let apiUrl;
            let mixedContentWarning = false;
            
            if (isLocalFile) {
                // æœ¬åœ°æ–‡ä»¶ç›´æ¥ä½¿ç”¨HTTP
                apiUrl = 'http://121.43.104.146:8088/v1/workflows/run';
            } else if (isHttps) {
                // HTTPSç¯å¢ƒä¸‹ä½¿ç”¨HTTP APIä¼šå¯¼è‡´æ··åˆå†…å®¹é—®é¢˜
                apiUrl = 'http://121.43.104.146:8088/v1/workflows/run';
                mixedContentWarning = true;
            } else {
                // HTTPç¯å¢ƒä¸‹ä½¿ç”¨HTTP API
                apiUrl = 'http://121.43.104.146:8088/v1/workflows/run';
            }
            
            console.log('ä½¿ç”¨çš„API URL:', apiUrl);
            console.log('å½“å‰ç¯å¢ƒ:', {
                isLocalFile,
                isHttps,
                isGitHubPages,
                mixedContentWarning
            });
            
            // å¦‚æœæ˜¯æ··åˆå†…å®¹ç¯å¢ƒï¼Œæ˜¾ç¤ºè¯¦ç»†çš„è­¦å‘Šä¿¡æ¯
            if (mixedContentWarning) {
                const warningMessage = `âš ï¸ è­¦å‘Šï¼šå½“å‰ä½¿ç”¨HTTPSé¡µé¢è®¿é—®HTTP APIï¼Œæµè§ˆå™¨ä¼šé˜»æ­¢æ··åˆå†…å®¹è¯·æ±‚ã€‚\n\n` +
                                      `è§£å†³æ–¹æ¡ˆï¼š\n` +
                                      `1. ç‚¹å‡»æµè§ˆå™¨åœ°å€æ çš„ğŸ”’æˆ–âš ï¸å›¾æ ‡\n` +
                                      `2. é€‰æ‹©"å…è®¸ä¸å®‰å…¨çš„å†…å®¹"æˆ–"åŠ è½½ä¸å®‰å…¨çš„è„šæœ¬"\n` +
                                      `3. åˆ·æ–°é¡µé¢å¹¶é‡è¯•\n\n` +
                                      `é•¿æœŸè§£å†³æ–¹æ¡ˆï¼šè¯·è”ç³»APIæœåŠ¡å™¨ç®¡ç†å‘˜é…ç½®SSLè¯ä¹¦ä»¥æ”¯æŒHTTPSã€‚`;
                
                console.warn(warningMessage);
                alert(warningMessage); // æ˜¾ç¤ºå¼¹çª—è­¦å‘Šç”¨æˆ·
            }
            fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer app-sEciSYvG1ecydvtGF9AQT4Ej',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestData)
            })
            .then(response => {
                console.log('æ”¶åˆ°å“åº”:', response);
                if (!response.ok) {
                    throw new Error(`Network response was not ok: ${response.status} ${response.statusText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder('utf-8');
                let buffer = '';
                let finalLink = null;
                const httpResult = document.getElementById('httpResult');
                httpResult.textContent = 'å¤„ç†ä¸­... è¯·ç¨å€™';
                httpResult.classList.add('loading');

                /** â­ æ·±åº¦æœç´¢æ•´ä¸ªå¯¹è±¡ä¸­çš„ http å­—æ®µï¼ˆè‡ªåŠ¨å¤„ç†æ•°ç»„ / åµŒå¥—å¯¹è±¡ï¼‰ */
                function deepFindHttp(obj) {
                    if (!obj) return null;

                    if (typeof obj === 'string' && obj.startsWith("http")) {
                        return obj;
                    }

                    if (typeof obj === 'object') {
                        if (obj.http && typeof obj.http === 'string') {
                            return obj.http;
                        }
                        for (const key in obj) {
                            const value = obj[key];
                            if (Array.isArray(value)) {
                                for (const item of value) {
                                    const found = deepFindHttp(item);
                                    if (found) return found;
                                }
                            } else if (typeof value === 'object') {
                                const found = deepFindHttp(value);
                                if (found) return found;
                            } else if (typeof value === 'string' && value.startsWith("http")) {
                                return value;
                            }
                        }
                    }
                    return null;
                }

                return reader.read().then(function processText({ done, value }) {
                    if (done) {
                        console.log("æµå·²å…³é—­");
                        httpResult.classList.remove('loading');
                        if (finalLink) {
                            httpResult.innerHTML = `æ–‡ä»¶é“¾æ¥: <a href="${finalLink}" target="_blank">${finalLink}</a>`;
                        } else {
                            httpResult.textContent = 'å¤„ç†å·²å®Œæˆï¼Œä½†æœªæ‰¾åˆ°é“¾æ¥ç»“æœ';
                        }
                        return;
                    }

                    const text = decoder.decode(value, { stream: true });
                    buffer += text;

                    const messages = buffer.split(/\r?\n\r?\n/);

                    for (let i = 0; i < messages.length - 1; i++) {
                        const message = messages[i];
                        if (!message.trim()) continue;

                        try {
                            const lines = message.split(/\r?\n/);
                            let eventType = null;
                            let eventData = null;

                            for (const line of lines) {
                                if (line.startsWith('event:')) {
                                    eventType = line.substring(6).trim();
                                } else if (line.startsWith('data:')) {
                                    const dataPart = line.substring(5).trim();
                                    if (dataPart) {
                                        try {
                                            eventData = JSON.parse(dataPart);
                                        } catch {}
                                    }
                                }
                            }

                            if (!eventType && eventData?.event) {
                                eventType = eventData.event;
                            }

                            if (eventData) {
                                console.log("äº‹ä»¶:", eventType, eventData);

                                if (eventType === "node_finished" || eventType === "workflow_finished" || eventType === "workflow_completed") {
                                    
                                    const foundLink = deepFindHttp(eventData);
                                    if (foundLink) {
                                        finalLink = foundLink.replace(/[`"'\s]/g, '');
                                        httpResult.textContent = finalLink;
                                    }
                                }
                            }

                        } catch (e) {
                            console.error("è§£æSSEæ¶ˆæ¯å‡ºé”™:", e);
                        }
                    }

                    buffer = messages[messages.length - 1];
                    return reader.read().then(processText);
                });
            })
            .catch(error => {
                console.error('è¯·æ±‚é”™è¯¯:', error);
                console.error('é”™è¯¯ç±»å‹:', error.name);
                console.error('é”™è¯¯ä¿¡æ¯:', error.message);
                console.error('é”™è¯¯å †æ ˆ:', error.stack);
                const httpResult = document.getElementById('httpResult');
                httpResult.classList.remove('loading');
                
                // æ£€æµ‹æ˜¯å¦æ˜¯æ··åˆå†…å®¹é”™è¯¯
                if (error.message.includes('mixed content') || error.message.includes('Mixed Content')) {
                    httpResult.innerHTML = `è¯·æ±‚å¤±è´¥: æµè§ˆå™¨é˜»æ­¢äº†æ··åˆå†…å®¹è¯·æ±‚<br/><br/>` +
                                          `è§£å†³æ–¹æ¡ˆï¼š<br/>` +
                                          `1. ç‚¹å‡»æµè§ˆå™¨åœ°å€æ çš„ğŸ”’æˆ–âš ï¸å›¾æ ‡<br/>` +
                                          `2. é€‰æ‹©"å…è®¸ä¸å®‰å…¨çš„å†…å®¹"<br/>` +
                                          `3. åˆ·æ–°é¡µé¢å¹¶é‡è¯•`;
                } else {
                    httpResult.innerHTML = `è¯·æ±‚å¤±è´¥: ${error.message}<br/><br/>` +
                                          `è¯·æŸ¥çœ‹æµè§ˆå™¨æ§åˆ¶å°è·å–è¯¦ç»†ä¿¡æ¯`;
                }
            });
        });
    </script>
</body>
</html>
